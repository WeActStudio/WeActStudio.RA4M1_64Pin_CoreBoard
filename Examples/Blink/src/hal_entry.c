#include "hal_data.h"

#include <stdio.h>

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

#define LED_TOGGLE R_PORT0->PODR ^= 1 << (BSP_IO_PORT_00_PIN_12 & 0xFF)

/*********************************************************************************************************************
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
   /* TODO: add your own code here */
	SystemCoreClock = 48000000;
	bsp_io_level_t ret;
	uint32_t tick;
	tick = 0;
	while (1)
	{
		R_IOPORT_PinRead(&g_ioport_ctrl, BSP_IO_PORT_00_PIN_13, &ret);

		tick++;

		if (ret == BSP_IO_LEVEL_LOW) {
			if (tick % 100 == 0) {
				R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_00_PIN_12, BSP_IO_LEVEL_HIGH);
			}
			if(tick % 200 == 0)
			{
				R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_00_PIN_12, BSP_IO_LEVEL_LOW);
			}
		}
		else
		{
			if (tick % 1000 == 0) {
				R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_00_PIN_12, BSP_IO_LEVEL_HIGH);
			}
			if(tick % 2000 == 0)
			{
				R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_00_PIN_12, BSP_IO_LEVEL_LOW);
			}
		}
     R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_MILLISECONDS);
   }
#if BSP_TZ_SECURE_BUILD
   /* Enter non-secure code */
   R_BSP_NonSecureEnter();
#endif
}

/* 调试串口 UART9 初始化 */
void Debug_UART9_Init(void)
{
   fsp_err_t err = FSP_SUCCESS;

   err = g_uart_on_sci.open(&g_uart9_ctrl, &g_uart9_cfg);
   assert(FSP_SUCCESS == err);
}
/* 发送完成标志 */
volatile bool uart_send_complete_flag = false;
/* 串口中断回调 */
void debug_uart9_callback(uart_callback_args_t *p_args)
{
   switch (p_args->event)
   {
   case UART_EVENT_RX_CHAR:
   {
      break;
   }
   case UART_EVENT_TX_COMPLETE:
   {
      uart_send_complete_flag = true;
      break;
   }
   default:
      break;
   }
}
/* 重定向 printf 输出 */
#if defined __GNUC__ && !defined __clang__
int _write(int fd, char *pBuffer, int size); // 防止编译警告
int _write(int fd, char *pBuffer, int size)
{
   (void)fd;
   R_SCI_UART_Write(&g_uart4_ctrl, (uint8_t *)pBuffer, (uint32_t)size);
   while (uart_send_complete_flag == false)
      ;
   uart_send_complete_flag = false;

   return size;
}
#else
int fputc(int ch, FILE *f)
{
   (void)f;
   g_uart_on_sci.write(&g_uart9_ctrl, (uint8_t *)&ch, 1);
   while (uart_send_complete_flag == false)
      ;
   uart_send_complete_flag = false;

   return ch;
}
#endif

/**********日期宏定义**********/
#define RTC_YEAR_SET 2023 // 年
#define RTC_MON_SET 8     // 月
#define RTC_MDAY_SET 26   // 日
/*通过蔡勒公式计算星期，1~6代表周一到周六，0代表周日*/
#define RTC_WDAY_SET (RTC_YEAR_SET - 2000 + ((RTC_YEAR_SET - 2000) / 4) - 35 + (26 * (RTC_MON_SET + 1)) / 10 + RTC_MDAY_SET - 1) % 7

/**********时间宏定义**********/
#define RTC_HOUR_SET 0 // 时
#define RTC_SEC_SET 0  // 秒
#define RTC_MIN_SET 0  // 分
R_RTC_Type *rtc;
R_SYSTEM_Type *system;


void RTC_Init(void)
{
	rtc = ((R_RTC_Type *) R_RTC_BASE);
	system = ((R_SYSTEM_Type *) R_SYSTEM_BASE);
   // 初始化时设定的时间
   rtc_time_t set_time =
       {
           .tm_sec = RTC_SEC_SET,          // 秒
           .tm_min = RTC_MIN_SET,          // 分
           .tm_hour = RTC_HOUR_SET,        // 小时
           .tm_mday = RTC_MDAY_SET,        // 日（一个月中）
           .tm_wday = RTC_WDAY_SET,        // 星期
           .tm_mon = RTC_MON_SET - 1,      // 月份，0~11代表11~12月
           .tm_year = RTC_YEAR_SET - 1900, // 年份（如今年是2008，则这里输入2008-1900=108）
       };
   /*打开RTC模块*/
   g_rtc_on_rtc.open(g_rtc0.p_ctrl, g_rtc0.p_cfg);

   /*时钟源设置，如果在FSP Configuration设置"Set Source Clock in Open"为"enabled"，那这一步可以被跳过*/
   g_rtc_on_rtc.clockSourceSet(g_rtc0.p_ctrl);

   /*若RTC时钟已经使用纽扣电池工作了一段时间，则可以使用这个函数获取当前日历并设置当前时间*/
   g_rtc_on_rtc.calendarTimeGet(g_rtc0.p_ctrl, &set_time);

   /*这个函数至少调用一次以启动RTC*/
   g_rtc_on_rtc.calendarTimeSet(g_rtc0.p_ctrl, &set_time); // 设置当前时间

   /*设置周期中断的周期为1秒*/
   g_rtc_on_rtc.periodicIrqRateSet(g_rtc0.p_ctrl, RTC_PERIODIC_IRQ_SELECT_1_SECOND);
}

void rtc_callback(rtc_callback_args_t *p_args)
{
   static rtc_time_t get_time;
   switch (p_args->event)
   {
   /*若是周期中断，则发送日期给串口并切换LED电平*/
   case RTC_EVENT_PERIODIC_IRQ:

      /*获取当前时间*/
      g_rtc_on_rtc.calendarTimeGet(g_rtc0.p_ctrl, &get_time);

      /*打印当前时间*/
      printf("\r\n%d-%d-%d-%d:%d:%d\r\n", get_time.tm_year + 1900, get_time.tm_mon + 1, get_time.tm_mday,
             get_time.tm_hour, get_time.tm_min, get_time.tm_sec);
      break;
   default:
      break;
   }
}

/*********************************************************************************************************************
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
   if (BSP_WARM_START_RESET == event)
   {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

      /* Enable reading from data flash. */
      R_FACI_LP->DFLCTL = 1U;

      /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
       * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
   }

   if (BSP_WARM_START_POST_C == event)
   {
      /* C runtime environment and system clocks are setup. */

      /* Configure pins. */
      R_IOPORT_Open(&g_ioport_ctrl, &IOPORT_CFG_NAME);

      Debug_UART9_Init();
      RTC_Init();
   }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable()
{
}
FSP_CPP_FOOTER

#endif
